<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jogo da Cobrinha</title>
  <style>
    :root{
      --bg:#0b1220; --panel:#0f1724; --accent:#4ade80; --muted:#94a3b8;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,system-ui,Roboto,"Helvetica Neue",Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071029 0%, #071a2a 100%);color:#e6eef8}
    .wrap{width:920px;max-width:96vw;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(2,6,23,0.6);display:grid;grid-template-columns:1fr 320px;gap:20px}
    header{grid-column:1/-1;display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
    h1{font-size:18px;margin:0;color:var(--accent)}
    p.lead{margin:0;color:var(--muted);font-size:13px}

    /* Canvas area */
    .game-area{background:var(--panel);border-radius:8px;padding:12px;display:flex;flex-direction:column;align-items:center}
    canvas{background:linear-gradient(180deg,#07172a,#042036);border-radius:6px;width:100%;height:auto;max-width:560px}

    /* Sidebar */
    aside{padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent);display:flex;flex-direction:column;gap:12px}
    .stats{display:flex;gap:8px;flex-wrap:wrap}
    .stat{flex:1;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;text-align:center}
    .stat .num{font-weight:700;font-size:20px;color:var(--accent)}
    .controls{display:flex;gap:8px;flex-direction:column}
    button{cursor:pointer;border:0;padding:10px 12px;border-radius:8px;background:rgba(255,255,255,0.03);color:inherit}
    button.primary{background:linear-gradient(90deg,#16a34a,#059669);box-shadow:0 6px 18px rgba(5,150,105,0.12)}
    .small{font-size:13px;padding:8px}
    footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;margin-top:6px}

    /* Touch controls */
    .touch-controls{display:none;gap:8px;justify-content:center}
    .touch-button{width:54px;height:54px;border-radius:8px;background:rgba(255,255,255,0.02);display:grid;place-items:center;font-weight:700}

    @media (max-width:900px){
      .wrap{grid-template-columns:1fr;}
      canvas{max-width:100%;height:320px}
      .touch-controls{display:flex}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Jogo da Cobrinha</h1>
        <p class="lead">Use setas / WASD — toque nos botões se estiver no celular. Espaço para pausar.</p>
      </div>
      <div style="text-align:right">
        <div style="font-size:12px;color:var(--muted)">Feito com JS puro • Single-file</div>
      </div>
    </header>

    <section class="game-area">
      <canvas id="gameCanvas" width="560" height="560" aria-label="Canvas do jogo da cobrinha"></canvas>
      <div style="width:100%;display:flex;justify-content:space-between;margin-top:10px;gap:8px;flex-wrap:wrap">
        <div style="font-size:13px;color:var(--muted)">Velocidade: <span id="speedLabel">8</span></div>
        <div style="font-size:13px;color:var(--muted)">Tamanho: <span id="sizeLabel">20</span></div>
        <div style="font-size:13px;color:var(--muted)">Modo: <span id="modeLabel">Clássico</span></div>
      </div>

      <!-- touch controls (shown on small screens) -->
      <div class="touch-controls" style="margin-top:12px">
        <div style="display:flex;flex-direction:column;gap:8px">
          <div class="touch-button" id="btnUp">▲</div>
          <div style="display:flex;gap:8px;justify-content:center">
            <div class="touch-button" id="btnLeft">◀</div>
            <div class="touch-button" id="btnDown">▼</div>
            <div class="touch-button" id="btnRight">▶</div>
          </div>
        </div>
      </div>
    </section>

    <aside>
      <div class="stats">
        <div class="stat"><div style="font-size:12px;color:var(--muted)">Pontos</div><div class="num" id="score">0</div></div>
        <div class="stat"><div style="font-size:12px;color:var(--muted)">Melhor</div><div class="num" id="highscore">0</div></div>
        <div class="stat"><div style="font-size:12px;color:var(--muted)">Comprimento</div><div class="num" id="length">1</div></div>
      </div>

      <div class="controls">
        <div style="display:flex;gap:8px">
          <button id="startBtn" class="primary">Iniciar</button>
          <button id="pauseBtn" class="small">Pausar</button>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <label style="font-size:13px;color:var(--muted)">Velocidade</label>
          <input id="speed" type="range" min="4" max="22" value="8" />
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <label style="font-size:13px;color:var(--muted)">Grade</label>
          <input id="gridSize" type="range" min="10" max="40" value="20" />
        </div>
        <div style="display:flex;gap:8px">
          <button id="classicMode" class="small">Clássico</button>
          <button id="wallMode" class="small">Sem Parede</button>
        </div>
        <div style="font-size:12px;color:var(--muted)">Dica: Aperte Espaço para pausar/reiniciar.</div>
      </div>

      <div style="margin-top:auto;font-size:12px;color:var(--muted)">Melhore: toque para pegar, evite colidir com o próprio corpo.</div>
    </aside>

    <footer>Controles: ← ↑ → ↓ ou WASD • Toque para controlar no celular</footer>
  </div>

  <script>
    // Game core
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const lengthEl = document.getElementById('length');
    const speedInput = document.getElementById('speed');
    const speedLabel = document.getElementById('speedLabel');
    const gridInput = document.getElementById('gridSize');
    const sizeLabel = document.getElementById('sizeLabel');
    const modeLabel = document.getElementById('modeLabel');

    let grid = parseInt(gridInput.value); // pixels per cell
    let cols = Math.floor(canvas.width / grid);
    let rows = Math.floor(canvas.height / grid);
    let snake = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
    let dir = {x:1,y:0};
    let food = null;
    let score = 0;
    let highscore = Number(localStorage.getItem('snakeHigh')||0);
    let running = false;
    let paused = false;
    let mode = 'classic'; // 'classic' or 'nowalls'
    let speed = parseInt(speedInput.value);
    let frameInterval = Math.max(30, 140 - speed*5);
    let tickTimer = null;

    highscoreEl.textContent = highscore;

    function resetGame(){
      grid = parseInt(gridInput.value);
      cols = Math.floor(canvas.width / grid);
      rows = Math.floor(canvas.height / grid);
      snake = [{x: Math.floor(cols/2), y: Math.floor(rows/2)}];
      dir = {x:1,y:0};
      score = 0; updateHUD();
      placeFood();
    }

    function placeFood(){
      let tries = 0;
      while(tries < 1000){
        const f = {x: Math.floor(Math.random()*cols), y: Math.floor(Math.random()*rows)};
        if(!snake.some(s=>s.x===f.x && s.y===f.y)){ food = f; break; }
        tries++;
      }
    }

    function updateHUD(){
      scoreEl.textContent = score;
      lengthEl.textContent = snake.length;
      speedLabel.textContent = speedInput.value;
      sizeLabel.textContent = gridInput.value;
      modeLabel.textContent = mode === 'classic' ? 'Clássico' : 'Sem Parede';
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // grid background
      ctx.fillStyle = '#02111a';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // food
      if(food){
        ctx.fillStyle = '#ef4444';
        roundRect(ctx, food.x*grid+grid*0.12, food.y*grid+grid*0.12, grid*0.76, grid*0.76, 6);
        ctx.fill();
      }

      // snake
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        const r = i===0 ? 6 : 4;
        ctx.fillStyle = i===0 ? '#60a5fa' : '#38bdf8';
        roundRect(ctx, s.x*grid+grid*0.06, s.y*grid+grid*0.06, grid*0.88, grid*0.88, r);
        ctx.fill();
      }

      // optional grid lines (subtle)
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for(let x=0;x<=cols;x++){ ctx.beginPath(); ctx.moveTo(x*grid,0); ctx.lineTo(x*grid,canvas.height); ctx.stroke(); }
      for(let y=0;y<=rows;y++){ ctx.beginPath(); ctx.moveTo(0,y*grid); ctx.lineTo(canvas.width,y*grid); ctx.stroke(); }
    }

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function gameTick(){
      if(paused) return;
      // compute next head
      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // wall handling
      if(mode === 'classic'){
        if(head.x < 0 || head.x >= cols || head.y < 0 || head.y >= rows){
          endGame(); return;
        }
      } else {
        // wrap
        if(head.x < 0) head.x = cols-1;
        if(head.x >= cols) head.x = 0;
        if(head.y < 0) head.y = rows-1;
        if(head.y >= rows) head.y = 0;
      }

      // self-collision
      if(snake.some(s=>s.x===head.x && s.y===head.y)) { endGame(); return; }

      // move
      snake.unshift(head);

      // eat
      if(food && head.x === food.x && head.y === food.y){
        score += Math.floor(10 + grid/2);
        placeFood();
      } else {
        snake.pop();
      }

      updateHUD();
      draw();
    }

    function endGame(){
      running = false;
      paused = true;
      clearInterval(tickTimer);
      if(score > highscore){ highscore = score; localStorage.setItem('snakeHigh', highscore); highscoreEl.textContent = highscore; }
      // small flash effect
      flashMessage('Fim de jogo! Pressione Iniciar ou Espaço para jogar novamente.');
    }

    function startLoop(){
      if(running) return;
      running = true; paused = false;
      frameInterval = Math.max(30, 160 - parseInt(speedInput.value)*6);
      tickTimer = setInterval(gameTick, frameInterval);
    }

    function pauseGame(){
      paused = !paused;
      if(paused){ clearInterval(tickTimer); flashMessage('Pausado'); }
      else startLoop();
    }

    function flashMessage(text){
      // quick on-canvas text
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, canvas.height/2 - 30, canvas.width, 60);
      ctx.fillStyle = '#fff';
      ctx.font = '18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(text, canvas.width/2, canvas.height/2 + 6);
      ctx.restore();
      setTimeout(draw, 900);
    }

    // input
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if(['arrowup','w'].includes(k) || k === 'w') tryChangeDir(0,-1);
      if(['arrowdown','s'].includes(k) || k === 's') tryChangeDir(0,1);
      if(['arrowleft','a'].includes(k) || k === 'a') tryChangeDir(-1,0);
      if(['arrowright','d'].includes(k) || k === 'd') tryChangeDir(1,0);
      if(e.code === 'Space'){
        if(!running){ resetGame(); startLoop(); }
        else pauseGame();
        e.preventDefault();
      }
    });

    function tryChangeDir(x,y){
      // prevent reversing
      if(snake.length > 1 && snake[1].x === snake[0].x + x && snake[1].y === snake[0].y + y) return;
      dir = {x,y};
      // immediately tick once for responsive control
      if(running && !paused){ gameTick(); }
    }

    // UI bindings
    document.getElementById('startBtn').addEventListener('click', ()=>{ resetGame(); startLoop(); });
    document.getElementById('pauseBtn').addEventListener('click', ()=>{ pauseGame(); });
    speedInput.addEventListener('input', ()=>{ speedLabel.textContent = speedInput.value; if(running){ clearInterval(tickTimer); startLoop(); } });
    gridInput.addEventListener('input', ()=>{ sizeLabel.textContent = gridInput.value; // recalc grid and reposition food
      // snapshot pixel-perfect ratio
      const prevCenter = {x: Math.floor((snake[0].x)/cols * (canvas.width/gridInput.value)), y: Math.floor((snake[0].y)/rows * (canvas.height/gridInput.value))};
      grid = parseInt(gridInput.value);
      cols = Math.floor(canvas.width / grid);
      rows = Math.floor(canvas.height / grid);
      resetGame(); draw();
    });

    document.getElementById('classicMode').addEventListener('click', ()=>{ mode='classic'; updateHUD(); });
    document.getElementById('wallMode').addEventListener('click', ()=>{ mode='nowalls'; updateHUD(); });

    // touch buttons
    ['btnUp','btnDown','btnLeft','btnRight'].forEach(id=>{
      const el = document.getElementById(id);
      if(!el) return;
      el.addEventListener('touchstart', e=>{ e.preventDefault(); if(id==='btnUp') tryChangeDir(0,-1);
        if(id==='btnDown') tryChangeDir(0,1); if(id==='btnLeft') tryChangeDir(-1,0); if(id==='btnRight') tryChangeDir(1,0);
      });
      el.addEventListener('mousedown', e=>{ e.preventDefault(); if(id==='btnUp') tryChangeDir(0,-1);
        if(id==='btnDown') tryChangeDir(0,1); if(id==='btnLeft') tryChangeDir(-1,0); if(id==='btnRight') tryChangeDir(1,0);
      });
    });

    // initial
    resetGame(); draw();

    // responsive canvas scaling
    function resizeCanvas(){
      // keep square but responsive
      const max = Math.min(560, Math.floor(window.innerWidth * 0.6));
      canvas.style.width = max + 'px';
      canvas.style.height = max + 'px';
    }
    window.addEventListener('resize', ()=>{ resizeCanvas(); });
    resizeCanvas();

  </script>
</body>
</html>
